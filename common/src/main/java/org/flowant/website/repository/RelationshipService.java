package org.flowant.website.repository;

import java.util.HashMap;

import org.flowant.website.model.ContentReputation;
import org.flowant.website.model.HasIdCid;
import org.flowant.website.model.HasReputation;
import org.flowant.website.model.IdCid;
import org.flowant.website.model.ReplyReputation;
import org.flowant.website.model.ReputationCounter;
import org.flowant.website.model.ReviewReputation;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Component
public class RelationshipService {

    static ContentRepository repoContent;
    static ReviewRepository repoReview;
    static ReplyRepository repoReply;
    static ContentReputationRepository repoContentRpt;
    static ReviewReputationRepository repoReviewRpt;
    static ReplyReputationRepository repoReplyRpt;

    static HashMap<Class<?>, ReputationRepository<? extends HasReputation>> repoParent = new HashMap<>();
    static Flux<IdCidRepository<?>> repoChildren;

    @Autowired
    RelationshipService(ContentRepository repoContent,
                        ReviewRepository repoReview,
                        ReplyRepository repoReply,
                        ContentReputationRepository repoContentRpt,
                        ReviewReputationRepository repoReviewRpt,
                        ReplyReputationRepository repoReplyRpt) {

        RelationshipService.repoContent = repoContent;
        RelationshipService.repoReview = repoReview;
        RelationshipService.repoReply = repoReply;
        RelationshipService.repoContentRpt = repoContentRpt;
        RelationshipService.repoReviewRpt = repoReviewRpt;
        RelationshipService.repoReplyRpt = repoReplyRpt;

        repoParent.put(ContentReputation.class, repoContent);
        repoParent.put(ReviewReputation.class, repoReview);
        repoParent.put(ReplyReputation.class, repoReply);

        repoChildren = Flux.just(repoReview, repoReply, repoContentRpt, repoReviewRpt, repoReplyRpt).cache();
    }

    // delete content and all children
    public static Mono<Void> deleteChildren(IdCid idCid) {
        return repoChildren
                .flatMap(repo -> repo.deleteAllByIdCidContainerId(idCid.getContainerId()))
                .then();
    }

    // Update counter values or create row if not exist from XReputationRepository to XRepository.
    public static <T extends ReputationCounter> Mono<T> updateReputation(T reputationCounter) {
        ReputationRepository<?> repo = repoParent.get(reputationCounter.getClass());
        return repo.updateReputationById(reputationCounter.getIdCid(), reputationCounter.toReputation())
                .thenReturn(reputationCounter);
    }

    // Used to check results of updateReputation method in test cases.
    public static <T extends ReputationCounter> Mono<? extends HasReputation> findReputation(T reputationCounter) {
        ReputationRepository<? extends HasIdCid> repo = repoParent.get(reputationCounter.getClass());
        return repo.findById(reputationCounter.getIdCid());
    }

    // Used for cleaning up test data generated by test cases.
    public static <T extends HasIdCid> Mono<Void> deleteParent(T entity) {
        ReputationRepository<?> repo = repoParent.get(entity.getClass());
        return repo.deleteById(entity.getIdCid());
    }

}
