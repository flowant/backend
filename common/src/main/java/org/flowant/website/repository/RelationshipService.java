package org.flowant.website.repository;

import java.util.Collection;
import java.util.Comparator;
import java.util.HashMap;
import java.util.PriorityQueue;
import java.util.UUID;

import org.flowant.website.model.Content;
import org.flowant.website.model.ContentReputation;
import org.flowant.website.model.HasIdCid;
import org.flowant.website.model.HasReputation;
import org.flowant.website.model.IdCid;
import org.flowant.website.model.ReplyReputation;
import org.flowant.website.model.ReputationCounter;
import org.flowant.website.model.Review;
import org.flowant.website.model.ReviewReputation;
import org.flowant.website.model.WebSite;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Component;

import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

@Component
public class RelationshipService {

    // prevent out of memory
    static int MAX_HEAP_SIZE = 1000;

    static ContentRepository repoContent;
    static ReviewRepository repoReview;
    static ReplyRepository repoReply;
    static ContentReputationRepository repoContentRpt;
    static ReviewReputationRepository repoReviewRpt;
    static ReplyReputationRepository repoReplyRpt;

    static HashMap<Class<?>, ReputationRepository<? extends HasReputation>> repoParent = new HashMap<>();

    static HashMap<Class<?>, ReputationCounterRepository<? extends HasIdCid>> repoCounter = new HashMap<>();

    static Flux<IdCidRepository<?>> repoChildren;

    @Autowired
    RelationshipService(ContentRepository repoContent,
                        ReviewRepository repoReview,
                        ReplyRepository repoReply,
                        ContentReputationRepository repoContentRpt,
                        ReviewReputationRepository repoReviewRpt,
                        ReplyReputationRepository repoReplyRpt) {

        RelationshipService.repoContent = repoContent;
        RelationshipService.repoReview = repoReview;
        RelationshipService.repoReply = repoReply;
        RelationshipService.repoContentRpt = repoContentRpt;
        RelationshipService.repoReviewRpt = repoReviewRpt;
        RelationshipService.repoReplyRpt = repoReplyRpt;

        repoParent.put(ContentReputation.class, repoContent);
        repoParent.put(ReviewReputation.class, repoReview);
        repoParent.put(ReplyReputation.class, repoReply);

        repoCounter.put(WebSite.class, repoContentRpt);
        repoCounter.put(Content.class, repoReviewRpt);
        repoCounter.put(Review.class, repoReplyRpt);

        repoChildren = Flux.just(repoReview, repoReply, repoContentRpt, repoReviewRpt, repoReplyRpt).cache();

    }

    // delete content and all children
    public static Mono<Void> deleteChildren(IdCid idCid) {
        return repoChildren
                .flatMap(repo -> repo.deleteAllByIdCidContainerId(idCid.getContainerId()))
                .then();
    }

    // Update counter values or create row if not exist from XReputationRepository to XRepository.
    public static <T extends ReputationCounter> Mono<T> updateReputation(T reputationCounter) {
        ReputationRepository<?> repo = repoParent.get(reputationCounter.getClass());
        return repo.updateReputationById(reputationCounter.getIdCid(), reputationCounter.toReputation())
                .thenReturn(reputationCounter);
    }

    // Used to check results of updateReputation method in test cases.
    public static <T extends ReputationCounter> Mono<? extends HasReputation> findReputation(T reputationCounter) {
        ReputationRepository<? extends HasIdCid> repo = repoParent.get(reputationCounter.getClass());
        return repo.findById(reputationCounter.getIdCid());
    }

    // Used for cleaning up test data generated by test cases.
    public static <T extends HasIdCid> Mono<Void> deleteParent(T entity) {
        ReputationRepository<?> repo = repoParent.get(entity.getClass());
        return repo.deleteById(entity.getIdCid());
    }

    // Be careful, it's very heavy IO bound function.
    public static Mono<Collection<ReputationCounter>> popularChildren(int cntPopular, UUID containerId, Class<?> containerCls) {

        ReputationCounterRepository<?> repo = repoCounter.get(containerCls);

        int maxSize = Math.min(cntPopular + 1, MAX_HEAP_SIZE);

        PriorityQueue<ReputationCounter> minHeap = new PriorityQueue<>(maxSize + 1,
                Comparator.comparing(ReputationCounter::getLiked));

        // TODO restrict amount of IO
        return repo.findAllByIdCidContainerId(containerId)
                .doOnNext(r -> {
                    minHeap.add(r); // log n
                    // This way is faster than using MinMaxPriorityQueue with max size although remove() is used.
                    if (minHeap.size() == maxSize) {
                        minHeap.remove(); // log n
                    }
                }).then(Mono.just(minHeap));
    }

}
